#ifndef DALI_TOOLKIT_TOOLKIT_INPUT_METHOD_CONTEXT_H
#define DALI_TOOLKIT_TOOLKIT_INPUT_METHOD_CONTEXT_H

/*
 * Copyright (c) 2019 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// EXTERNAL INCLUDES
#define DALI_INPUT_METHOD_CONTEXT_H
#include <dali/devel-api/adaptor-framework/input-method-options.h>
#include <dali/public-api/actors/actor.h>
#include <dali/public-api/events/key-event.h>
#include <dali/public-api/object/base-handle.h>
#include <dali/public-api/signals/dali-signal.h>

namespace Dali DALI_IMPORT_API
{

namespace Internal DALI_INTERNAL
{
namespace Adaptor
{
class InputMethodContext;
}
} //namespace Internal DALI_INTERNAL

/**
 * @brief The InputMethodContext class
 *
 * Specifically manages the ecore input method framework which enables the virtual or hardware keyboards.
 */
class InputMethodContext : public BaseHandle
{
public:
  /**
   * @brief The direction of text.
   */
  enum TextDirection
  {
    LeftToRight,
    RightToLeft,
  };

  /**
   * @brief Events that are generated by the InputMethodContext.
   */
  enum EventType
  {
    VOID,               ///< No event
    PRE_EDIT,           ///< Pre-Edit changed
    COMMIT,             ///< Commit recieved
    DELETE_SURROUNDING, ///< Event to delete a range of characters from the string
    GET_SURROUNDING,    ///< Event to query string and cursor position
    PRIVATE_COMMAND,    ///< Private command sent from the input panel
    SELECTION_SET       ///< input method needs to set the selection
  };

  /**
   * @brief Enumeration for state of the input panel.
   */
  enum State
  {
    DEFAULT = 0, ///< Unknown state
    SHOW,        ///< Input panel is shown
    HIDE,        ///< Input panel is hidden
    WILL_SHOW    ///< Input panel in process of being shown
  };

  /**
   * @brief Enumeration for the type of Keyboard.
   */
  enum KeyboardType
  {
    SOFTWARE_KEYBOARD, ///< Software keyboard (Virtual keyboard) is default
    HARDWARE_KEYBOARD  ///< Hardware keyboard
  };

  /**
   * @brief Enumeration for the language mode of the input panel.
   */
  enum class InputPanelLanguage
  {
    AUTOMATIC, ///< IME Language automatically set depending on the system display
    ALPHABET   ///< Latin alphabet at all times
  };

  /**
   * @brief Enumeration for the preedit style types.
   */
  enum class PreeditStyle
  {
    NONE,                    ///< None style
    UNDERLINE,               ///< Underline substring style
    REVERSE,                 ///< Reverse substring style
    HIGHLIGHT,               ///< Highlight substring style
    CUSTOM_PLATFORM_STYLE_1, ///< Custom style for platform
    CUSTOM_PLATFORM_STYLE_2, ///< Custom style for platform
    CUSTOM_PLATFORM_STYLE_3, ///< Custom style for platform
    CUSTOM_PLATFORM_STYLE_4  ///< Custom style for platform
  };

  /**
   * @brief This structure is for the preedit style types and indices.
   */
  struct PreeditAttributeData
  {
    PreeditAttributeData()
    : preeditType(PreeditStyle::NONE),
      startIndex(0),
      endIndex(0)
    {
    }

    PreeditStyle preeditType; /// The preedit style type
    unsigned int startIndex;  /// The start index of preedit
    unsigned int endIndex;    /// The end index of preedit
  };

  /**
   * @brief This structure is used to pass on data from the InputMethodContext regarding predictive text.
   */
  struct EventData
  {
    /**
     * @brief Default Constructor.
     */
    EventData()
    : predictiveString(),
      eventName(VOID),
      cursorOffset(0),
      numberOfChars(0),
      startIndex(0),
      endIndex(0) {
      };

    /**
     * @brief Constructor
     *
     * @param[in] aEventName The name of the event from the input method context.
     * @param[in] aPredictiveString The pre-edit or commit string.
     * @param[in] aCursorOffset Start position from the current cursor position to start deleting characters.
     * @param[in] aNumberOfChars The number of characters to delete from the cursorOffset.
     */
    EventData(EventType aEventName, const std::string& aPredictiveString, int aCursorOffset, int aNumberOfChars)
    : predictiveString(aPredictiveString),
      eventName(aEventName),
      cursorOffset(aCursorOffset),
      numberOfChars(aNumberOfChars),
      startIndex(0),
      endIndex(0)
    {
    }

    /**
     * @brief Constructor
     *
     * @param[in] aEventName The name of the event from the InputMethodContext.
     * @param[in] aStartIndex The start index of selection.
     * @param[in] aEndIndex The end index of selection.
     */
    EventData(EventType aEventName, int aStartIndex, int aEndIndex)
    : predictiveString(),
      eventName(aEventName),
      cursorOffset(0),
      numberOfChars(0),
      startIndex(aStartIndex),
      endIndex(aEndIndex)
    {
    }

    // Data
    std::string predictiveString; ///< The pre-edit or commit string.
    EventType   eventName;        ///< The name of the event from the input method context.
    int         cursorOffset;     ///< Start position from the current cursor position to start deleting characters.
    int         numberOfChars;    ///< number of characters to delete from the cursorOffset.
    int         startIndex;       ///< The start index of selection.
    int         endIndex;         ///< The end index of selection.
  };

  /**
   * @brief Data required by input method context from the callback
   */
  struct CallbackData
  {
    /**
     * @brief Constructor
     */
    CallbackData()
    : currentText(),
      cursorPosition(0),
      update(false),
      preeditResetRequired(false)
    {
    }

    /**
     * @brief Constructor
     * @param[in] aUpdate True if cursor position needs to be updated
     * @param[in] aCursorPosition new position of cursor
     * @param[in] aCurrentText current text string
     * @param[in] aPreeditResetRequired flag if preedit reset is required.
     */
    CallbackData(bool aUpdate, int aCursorPosition, const std::string& aCurrentText, bool aPreeditResetRequired)
    : currentText(aCurrentText),
      cursorPosition(aCursorPosition),
      update(aUpdate),
      preeditResetRequired(aPreeditResetRequired)
    {
    }

    std::string currentText;              ///< current text string
    int         cursorPosition;           ///< new position of cursor
    bool        update : 1;               ///< if cursor position needs to be updated
    bool        preeditResetRequired : 1; ///< flag if preedit reset is required.
  };

  typedef Signal<void(InputMethodContext&)>                           ActivatedSignalType;     ///< Keyboard actived signal
  typedef Signal<CallbackData(InputMethodContext&, const EventData&)> KeyboardEventSignalType; ///< keyboard events
  typedef Signal<void()>                                              VoidSignalType;
  typedef Signal<void(bool)>                                          StatusSignalType;

  using PreEditAttributeDataContainer = Vector<Dali::InputMethodContext::PreeditAttributeData>;

public:
  /**
   * @brief Create a handle to the instance of InputMethodContext.
   * @return A handle to the InputMethodContext.
   */
  static InputMethodContext New();

  /**
   * @brief Create a handle to the instance of InputMethodContext.
   *
   * @param[in] actor The actor that uses the new InputMethodContext instance.
   * @return A handle to the InputMethodContext.
   */
  static InputMethodContext New(Actor actor);

  /**
   * @brief Finalize the InputMethodContext.
   *
   * It means that the context will be deleted.
   */
  void Finalize();

  /**
   * @brief Activate the input method context.
   *
   * It means that the text editing is started at somewhere.
   * If the H/W keyboard isn't connected then it will show the virtual keyboard.
   */
  void Activate();

  /**
   * @brief Deactivate the input method context.
   *
   * It means that the text editing is finished at somewhere.
   */
  void Deactivate();

  /**
   * @brief Get the restoration status, which controls if the keyboard is restored after the focus lost then regained.
   *
   * If true then keyboard will be restored (activated) after focus is regained.
   * @return restoration status.
   */
  bool RestoreAfterFocusLost() const;

  /**
   * @brief Set status whether the input method context has to restore the keyboard after losing focus.
   *
   * @param[in] toggle True means that keyboard should be restored after focus lost and regained.
   */
  void SetRestoreAfterFocusLost(bool toggle);

  /**
   * @brief Send message reset the pred-edit state / input method context module.
   *
   * Used to interupt pre-edit state maybe due to a touch input.
   */
  void Reset();

  /**
   * @brief Notifies ImfContext that the cursor position has changed, required for features like auto-capitalisation.
   */
  void NotifyCursorPosition();

  /**
   * @brief Sets cursor position stored in VirtualKeyboard, this is required by the ImfContext.
   *
   * @param[in] cursorPosition position of cursor
   */
  void SetCursorPosition(unsigned int cursorPosition);

  /**
   * @brief Gets cursor position stored in VirtualKeyboard, this is required by the ImfContext.
   *
   * @return current position of cursor
   */
  unsigned int GetCursorPosition() const;

  /**
   * @brief Method to store the string required by the input method context, this is used to provide predictive word suggestions.
   *
   * @param[in] text The text string surrounding the current cursor point.
   */
  void SetSurroundingText(const std::string& text);

  /**
   * @brief Gets current text string set within the input method context, this is used to offer predictive suggestions.
   *
   * @return current position of cursor
   */
  const std::string& GetSurroundingText() const;

  /**
   * @brief Notifies ImfContext that text input is set to multi line or not
   */
  void NotifyTextInputMultiLine(bool multiLine);

  /**
   * @brief Set one or more of the Input Method options
   * @param[in] options The options to be applied
   */
  void ApplyOptions(const InputMethodOptions& options);

  /**
   * @brief Process event key down or up, whether filter a key to isf.
   *
   * @param[in] keyEvent The event key to be handled.
   * @return Whether the event key is handled.
   */
  bool FilterEventKey(const Dali::KeyEvent& keyEvent);

  /**
   * @brief Sets the preedit type.
   *
   * @param[in] type The preedit style type
   */
  void SetPreeditStyle(PreeditStyle type);

  /**
   * @brief Gets the preedit attributes data.
   *
   * @param[out] attrs The preedit attributes data.
   */
  void GetPreeditStyle(Dali::InputMethodContext::PreEditAttributeDataContainer& attrs) const;

public:
  // Signals

  /**
   * @brief This is emitted when the virtual keyboard is connected to or the hardware keyboard is activated.
   *
   * @return The input method context Activated signal.
   */
  ActivatedSignalType& ActivatedSignal();

  /**
   * @brief This is emitted when the InputMethodContext receives an event from the InputMethodContext.
   * @note This signal is the same as KeyboardEventReceivedSignal().
   * This signal is bound to dali-csharp-binder and can be used in external apps.
   *
   * @return The Event signal containing the event data.
   */
  KeyboardEventSignalType& EventReceivedSignal();

  /**
   * @brief This is emitted when the InputMethodContext receives an event from the InputMethodContext.
   * @note This signal is the same as EventReceivedSignal().
   * This signal is only used by dali.
   *
   * The EventReceivedSignal combines different kinds of events triggered by the IMF into a single signal, which it then emits.
   * These events often happen during text entry through S/W keyboard and Applications depend on this signal to perform various actions.
   * There exists a situation where further emissions take place inside the emitted signal.
   * Unfortunately, these events are already exposed publicly and cannot be segregated separately.
   * As a workaround, we keep the original signal intact but separate signals meant exclusively for usage within dali.
   *
   * @return The Event signal containing the event data.
   */
  KeyboardEventSignalType& KeyboardEventReceivedSignal();

  /**
   * @brief Connect to this signal to be notified when the virtual keyboard is shown or hidden.
   *
   * @return The signal connect to status changed event.
   */
  StatusSignalType& StatusChangedSignal();

  /**
   * @brief Connect to this signal to be notified when the virtual keyboard is resized.
   *
   * @return The signal to connect to resized event.
   */
  VoidSignalType& ResizedSignal();

  /**
   * @brief Connect to this signal to be notified when the virtual keyboard's language is changed.
   *
   * @return The signal to connect to language changed event.
   */
  VoidSignalType& LanguageChangedSignal();

  // Construction & Destruction

  /**
   * @brief Constructor.
   */
  InputMethodContext();

  /**
   * @brief Destructor
   *
   * This is non-virtual since derived Handle types must not contain data or virtual methods.
   */
  ~InputMethodContext();

  /**
   * @brief This constructor is used by InputMethodContext::Get().
   *
   * @param[in] inputMethodContext A pointer to the input method context.
   */
  explicit InputMethodContext(Internal::Adaptor::InputMethodContext* inputMethodContext);
};

} //namespace Dali DALI_IMPORT_API

#endif // DALI_TOOLKIT_TOOLKIT_INPUT_METHOD_CONTEXT_H
